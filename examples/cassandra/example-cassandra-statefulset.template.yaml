AWSTemplateFormatVersion: "2010-09-09"
Description: "Deploy cassandra using portwox volume"
Parameters:
  KubeManifestLambdaArn:
    Type: String
  KubeConfigPath:
    Type: String
  KubeConfigKmsContext:
    Type: String
    Default: "EKSQuickStart"
  PortworxStorageSize:
    Type: String
    Default: "10Gi"
  CassandraContainerImage:
    Type: String
    Default: "gcr.io/google-samples/cassandra:v12"
Resources:
  # This resource creates a ConfigMap in the target cluster. It retrieves and decrypts a kms encrypted
  # kubernetes config file, which is automatically created when customers deploy an EKS cluster with the quickstart,
  # for bring-your-own-cluster the customer must encrypt and upload a config file prior to launching the stack.
  #
  # The "Manifest" property is an exact representation of a regular kubernetes resource manifest, on stack create
  # `kubectl create --save-config` is called, on stack update `kubectl apply` and on stack delete `kubectl delete`
  #
  # The following elements are available to be used in other cloudformation resources using !GetAtt:
  # name, namespace, resourceVersion, selfLink, uid
  KubeManifestCassandraStatefulSetStack:
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      # The lambda function that executes the manifest against the cluster. This is created in one of the parent stacks
      ServiceToken: !Ref KubeManifestLambdaArn
      # S3 path to the encrypted config file eg. s3://my-bucket/kube/config.encrypted
      KubeConfigPath: !Ref KubeConfigPath
      # context for KMS to use when decrypting the file
      KubeConfigKmsContext: !Ref KubeConfigKmsContext
      PortworxStorageSize: !Ref PortworxStorageSize
      CassandraContainerImage: !Ref CassandraContainerImage
      # Kubernetes manifest
      Manifest: !Sub |
        apiVersion: "apps/v1beta1"
        kind: StatefulSet
        metadata:
          name: cassandra
        spec:
          serviceName: cassandra
          replicas: 3
          template:
            metadata:
              labels:
                app: cassandra
            spec:
              # Use the stork scheduler to enable more efficient placement of the pods
              schedulerName: stork
              containers:
              - name: cassandra
                image: "${CassandraContainerImage}"
                imagePullPolicy: Always
                ports:
                - containerPort: 7000
                  name: intra-node
                - containerPort: 7001
                  name: tls-intra-node
                - containerPort: 7199
                  name: jmx
                - containerPort: 9042
                  name: cql
                securityContext:
                  capabilities:
                    add:
                      - IPC_LOCK
                lifecycle:
                  preStop:
                    exec:
                      command: ["/bin/sh", "-c", "PID=$(pidof java) && kill $PID && while ps -p $PID > /dev/null; do sleep 1; done"]
                env:
                  - name: MAX_HEAP_SIZE
                    value: 1024M
                  - name: HEAP_NEWSIZE
                    value: 500M
                  - name: CASSANDRA_SEEDS
                    value: "cassandra-0.cassandra.default.svc.cluster.local"
                  - name: CASSANDRA_CLUSTER_NAME
                    value: "K8Demo"
                  - name: CASSANDRA_DC
                    value: "DC1-K8Demo"
                  - name: CASSANDRA_RACK
                    value: "Rack1-K8Demo"
                  - name: CASSANDRA_AUTO_BOOTSTRAP
                    value: "false"
                  - name: POD_IP
                    valueFrom:
                      fieldRef:
                        fieldPath: status.podIP
                  - name: POD_NAMESPACE
                    valueFrom:
                      fieldRef:
                        fieldPath: metadata.namespace
                readinessProbe:
                  exec:
                    command:
                    - /bin/bash
                    - -c
                    - /ready-probe.sh
                  initialDelaySeconds: 15
                  timeoutSeconds: 5
                # These volume mounts are persistent. They are like inline claims,
                # but not exactly because the names need to match exactly one of
                # the stateful pod volumes.
                volumeMounts:
                - name: cassandra-data
                  mountPath: /cassandra_data
          # These are converted to volume claims by the controller
          # and mounted at the paths mentioned above.
          volumeClaimTemplates:
          - metadata:
              name: cassandra-data
              annotations:
                volume.beta.kubernetes.io/storage-class: px-cassandra-storageclass
            spec:
              accessModes: [ "ReadWriteOnce" ]
              resources:
                requests:
                  storage: '${PortworxStorageSize}'
Outputs:
  # Examples for using the outputs of the KubeManifestExample resource
  CassandraStatefulSetStackUid:
    Value: !GetAtt KubeManifestCassandraStatefulSetStack.uid
  CassandraStatefulSetStackSelfLink:
    Value: !Ref KubeManifestCassandraStatefulSetStack
