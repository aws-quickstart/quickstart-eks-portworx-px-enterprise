AWSTemplateFormatVersion: "2010-09-09"
Description: Deploys Portworx Enterprise into an existing Kubernetes Cluster (qs-1pb1dqsjr)
Metadata:
  QSLint:
    Exclusions: [ W9002, W9003, W9004, W9006 ]
  cfn-lint:
    config:
      ignore_checks:
        - E9904
        - E9902
        - W9901
        - EIAMPolicyWildcardResource
      ignore_reasons:
        EIAMPolicyWildcardResource: (Line 1289-1312) Done by Design
  AWS::CloudFormation::Interface:
    ParameterGroups:
    - Label:
        default: Portworx Configuration
      Parameters:
      - PXKubernetesVersion
      - PortworxVersion
      - LightHouseVersion
      - VolumeTemplateString
      - MetadataTemplateString
    ParameterLabels:
      PXKubernetesVersion:
        default: The EKS version used scheduler container image tags
      PortworxVersion:
        default: Version of portworx X.Y.Z
      LightHouseVersion:
        default: Version of Lighthouse X.Y.Z
      VolumeTemplateString:
        default: The template string (https://docs.portworx.com/cloud-references/auto-disk-provisioning/aws/)
      MetadataTemplateString:
        default: The template string for metadata device for internal KVDB
Parameters:
  KubeManifestLambdaArn:
    Type: String
  KubeConfigPath:
    Type: String
  KubeConfigKmsContext:
    Type: String
    Default: "EKSQuickStart"
  PortworxClusterName:
    Type: String
    Description: The name of the portworx Cluster
  NodeGroupIAMRole:
    Type: String
    Description: The IAM NodeGroup Role for the Portworx Nodes (EKS Worker Nodes)
  PXKubernetesVersion:
    Type: String
    Default: "1.13"
    Description:  The EKS version used scheduler container image tags
  PortworxVersion:
    Type: String
    Default: "2.2.0"
    Description: Version of portworx X.Y.Z
  LightHouseVersion:
    Type: String
    Default: "2.0.5"
    Description: Version of Lighthouse X.Y.Z
  VolumeTemplateString:
    Type: String
    Default: "type=gp2,size=100"
    Description: The template string (https://docs.portworx.com/cloud-references/auto-disk-provisioning/aws/)
  MetadataTemplateString:
    Type: String
    Default: "type=gp2,size=100"
    Description: The template string (https://docs.portworx.com/cloud-references/auto-disk-provisioning/aws/)
  PortworxPxEnabledNotInValue:
    Type: String
    Default: "false"
    Description: Dont deploy Portworx deploy if px/enabled equal
Resources:
  PortworxNamespaceStack:
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      # The lambda function that executes the manifest against the cluster. This is created in one of the parent stacks
      ServiceToken: !Ref KubeManifestLambdaArn
      # S3 path to the encrypted config file eg. s3://my-bucket/kube/config.encrypted
      KubeConfigPath: !Ref KubeConfigPath
      # context for KMS to use when decrypting the file
      KubeConfigKmsContext: !Ref KubeConfigKmsContext
      # Kubernetes manifest
      Manifest:
        apiVersion: v1
        kind: Namespace
        metadata:
          name: portworx
  PortworxDaemonSetStack:
    DependsOn: PortworxNamespaceStack
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      # The lambda function that executes the manifest against the cluster. This is created in one of the parent stacks
      ServiceToken: !Ref KubeManifestLambdaArn
      # S3 path to the encrypted config file eg. s3://my-bucket/kube/config.encrypted
      KubeConfigPath: !Ref KubeConfigPath
      # context for KMS to use when decrypting the file
      KubeConfigKmsContext: !Ref KubeConfigKmsContext
      # Cluster name to use in daemonset
      PortworxClusterName: !Ref PortworxClusterName
      # Portworx Version
      PortworxVersion: !Ref PortworxVersion
      # Portworx PxEnabledNotInValue
      PortworxPxEnabledNotInValue: !Ref PortworxPxEnabledNotInValue
      # Kubernetes manifest
      Manifest: !Sub |
        apiVersion: extensions/v1beta1
        kind: DaemonSet
        metadata:
          name: portworx
          namespace: kube-system
          annotations:
            portworx.com/install-source: "https://install.portworx.com"
        spec:
          minReadySeconds: 0
          updateStrategy:
            type: RollingUpdate
            rollingUpdate:
              maxUnavailable: 1
          template:
            metadata:
              labels:
                name: portworx
            spec:
              affinity:
                nodeAffinity:
                  requiredDuringSchedulingIgnoredDuringExecution:
                    nodeSelectorTerms:
                    - matchExpressions:
                      - key: px/enabled
                        operator: NotIn
                        values:
                        - "${PortworxPxEnabledNotInValue}"
                      - key: node-role.kubernetes.io/master
                        operator: DoesNotExist
              hostNetwork: true
              hostPID: false
              containers:
                - name: portworx
                  image: "portworx/oci-monitor:${PortworxVersion}"
                  imagePullPolicy: Always
                  args:
                    ["-b", "-c", "${PortworxClusterName}", 
                     "-s", "${VolumeTemplateString}", 
                     "-metadata", "${MetadataTemplateString}", 
                     "-secret_type", "k8s", 
                     "-x", "kubernetes"]
                  env:
                    - name: "AUTO_NODE_RECOVERY_TIMEOUT_IN_SECS"
                      value: "1500"
                    - name: "PX_TEMPLATE_VERSION"
                      value: "v4"
                    
                  livenessProbe:
                    periodSeconds: 30
                    initialDelaySeconds: 840 # allow image pull in slow networks
                    httpGet:
                      host: 127.0.0.1
                      path: /status
                      port: 9001
                  readinessProbe:
                    periodSeconds: 10
                    httpGet:
                      host: 127.0.0.1
                      path: /health
                      port: 9015
                  terminationMessagePath: "/tmp/px-termination-log"
                  securityContext:
                    privileged: true
                  volumeMounts:
                    - name: diagsdump
                      mountPath: /var/cores
                    - name: dockersock
                      mountPath: /var/run/docker.sock
                    - name: containerdsock
                      mountPath: /run/containerd
                    - name: criosock
                      mountPath: /var/run/crio
                    - name: crioconf
                      mountPath: /etc/crictl.yaml
                    - name: etcpwx
                      mountPath: /etc/pwx
                    - name: dev
                      mountPath: /dev
                    - name: optpwx
                      mountPath: /opt/pwx
                    - name: procmount
                      mountPath: /host_proc
                    - name: sysdmount
                      mountPath: /etc/systemd/system
                    - name: journalmount1
                      mountPath: /var/run/log
                      readOnly: true
                    - name: journalmount2
                      mountPath: /var/log
                      readOnly: true
                    - name: dbusmount
                      mountPath: /var/run/dbus
              restartPolicy: Always
              serviceAccountName: px-account
              volumes:
                - name: diagsdump
                  hostPath:
                    path: /var/cores
                - name: dockersock
                  hostPath:
                    path: /var/run/docker.sock
                - name: containerdsock
                  hostPath:
                    path: /run/containerd
                - name: criosock
                  hostPath:
                    path: /var/run/crio
                - name: crioconf
                  hostPath:
                    path: /etc/crictl.yaml
                    type: FileOrCreate
                - name: etcpwx
                  hostPath:
                    path: /etc/pwx
                - name: dev
                  hostPath:
                    path: /dev
                - name: optpwx
                  hostPath:
                    path: /opt/pwx
                - name: procmount
                  hostPath:
                    path: /proc
                - name: sysdmount
                  hostPath:
                    path: /etc/systemd/system
                - name: journalmount1
                  hostPath:
                    path: /var/run/log
                - name: journalmount2
                  hostPath:
                    path: /var/log
                - name: dbusmount
                  hostPath:
                    path: /var/run/dbus
  PXServiceAccountStack:
    DependsOn: PortworxNamespaceStack
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      # The lambda function that executes the manifest against the cluster. This is created in one of the parent stacks
      ServiceToken: !Ref KubeManifestLambdaArn
      # S3 path to the encrypted config file eg. s3://my-bucket/kube/config.encrypted
      KubeConfigPath: !Ref KubeConfigPath
      # context for KMS to use when decrypting the file
      KubeConfigKmsContext: !Ref KubeConfigKmsContext
      # Kubernetes manifest
      Manifest:
        apiVersion: v1
        kind: ServiceAccount
        metadata:
          name: px-account
          namespace: kube-system
  PXLightgouseServiceAccountStack:
    DependsOn: PortworxNamespaceStack
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      # The lambda function that executes the manifest against the cluster. This is created in one of the parent stacks
      ServiceToken: !Ref KubeManifestLambdaArn
      # S3 path to the encrypted config file eg. s3://my-bucket/kube/config.encrypted
      KubeConfigPath: !Ref KubeConfigPath
      # context for KMS to use when decrypting the file
      KubeConfigKmsContext: !Ref KubeConfigKmsContext
      # Kubernetes manifest
      Manifest:
        apiVersion: v1
        kind: ServiceAccount
        metadata:
          name: px-lh-account
          namespace: kube-system
  PXLightgouseDeploymentStack:
    DependsOn: PortworxNamespaceStack
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      # The lambda function that executes the manifest against the cluster. This is created in one of the parent stacks
      ServiceToken: !Ref KubeManifestLambdaArn
      # S3 path to the encrypted config file eg. s3://my-bucket/kube/config.encrypted
      KubeConfigPath: !Ref KubeConfigPath
      # context for KMS to use when decrypting the file
      KubeConfigKmsContext: !Ref KubeConfigKmsContext
      # Version of the UI
      LightHouseVersion: !Ref LightHouseVersion
      # Kubernetes manifest
      Manifest:
        apiVersion: apps/v1beta2
        kind: Deployment
        metadata:
          name: px-lighthouse
          namespace: kube-system
          labels:
            tier: px-web-console
        spec:
          replicas: 1
          strategy:
            rollingUpdate:
              maxSurge: 1
              maxUnavailable: 1
            type: RollingUpdate
          selector:
            matchLabels:
              tier: px-web-console
          template:
            metadata:
              labels:
                tier: px-web-console
            spec:
              initContainers:
              - name: config-init
                image: !Join [ ":", [ "portworx/lh-config-sync", !Ref LightHouseVersion ] ]
                imagePullPolicy: Always
                args:
                - "init"
                volumeMounts:
                - name: config
                  mountPath: /config/lh
              containers:
              - name: px-lighthouse
                image: !Join [ ":", [ "portworx/px-lighthouse", !Ref LightHouseVersion ] ]
                imagePullPolicy: Always
                ports:
                - containerPort: 80
                - containerPort: 443
                volumeMounts:
                - name: config
                  mountPath: /config/lh
              - name: config-sync
                image: !Join [ ":", [ "portworx/lh-config-sync", !Ref LightHouseVersion ] ]
                imagePullPolicy: Always
                args:
                - "sync"
                volumeMounts:
                - name: config
                  mountPath: /config/lh
              serviceAccountName: px-lh-account
              volumes:
              - name: config
                emptyDir: {}
  PXLighthouseRoleBindingStack:
    DependsOn: PortworxNamespaceStack
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      # The lambda function that executes the manifest against the cluster. This is created in one of the parent stacks
      ServiceToken: !Ref KubeManifestLambdaArn
      # S3 path to the encrypted config file eg. s3://my-bucket/kube/config.encrypted
      KubeConfigPath: !Ref KubeConfigPath
      # context for KMS to use when decrypting the file
      KubeConfigKmsContext: !Ref KubeConfigKmsContext
      # Kubernetes manifest
      Manifest:
        kind: ClusterRoleBinding
        apiVersion: rbac.authorization.k8s.io/v1
        metadata:
          name: px-lh-role-binding
          namespace: kube-system
        subjects:
        - kind: ServiceAccount
          name: px-lh-account
          namespace: kube-system
        roleRef:
          kind: ClusterRole
          name: px-lh-role
          apiGroup: rbac.authorization.k8s.io
  PXLighthouseRoleStack:
    DependsOn: PortworxNamespaceStack
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      # The lambda function that executes the manifest against the cluster. This is created in one of the parent stacks
      ServiceToken: !Ref KubeManifestLambdaArn
      # S3 path to the encrypted config file eg. s3://my-bucket/kube/config.encrypted
      KubeConfigPath: !Ref KubeConfigPath
      # context for KMS to use when decrypting the file
      KubeConfigKmsContext: !Ref KubeConfigKmsContext
      # Kubernetes manifest
      Manifest:
        kind: ClusterRole
        apiVersion: rbac.authorization.k8s.io/v1
        metadata:
          name: px-lh-role
          namespace: kube-system
        rules:
          - apiGroups: [""]
            resources: ["pods"]
            verbs: ["list", "get"]
          - apiGroups:
                - extensions
                - apps
            resources:
                - deployments
            verbs: ["get", "list"]
          - apiGroups: [""]
            resources: ["secrets"]
            verbs: ["get", "create", "update"]
          - apiGroups: [""]
            resources: ["configmaps"]
            verbs: ["get", "create", "update"]
          - apiGroups: [""]
            resources: ["nodes"]
            verbs: ["get", "list", "watch"]
          - apiGroups: [""]
            resources: ["services"]
            verbs: ["create", "get", "list", "watch"]
          - apiGroups: ["stork.libopenstorage.org"]
            resources: ["clusterpairs","migrations","groupvolumesnapshots"]
            verbs: ["get", "list", "create", "update", "delete"]
          - apiGroups: ["monitoring.coreos.com"]
            resources:
              - alertmanagers
              - prometheuses
              - prometheuses/finalizers
              - servicemonitors
            verbs: ["*"]
  PXLighthouseServiceStack:
    DependsOn: PortworxNamespaceStack
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      # The lambda function that executes the manifest against the cluster. This is created in one of the parent stacks
      ServiceToken: !Ref KubeManifestLambdaArn
      # S3 path to the encrypted config file eg. s3://my-bucket/kube/config.encrypted
      KubeConfigPath: !Ref KubeConfigPath
      # context for KMS to use when decrypting the file
      KubeConfigKmsContext: !Ref KubeConfigKmsContext
      # Kubernetes manifest
      Manifest:
        apiVersion: v1
        kind: Service
        metadata:
          name: px-lighthouse
          namespace: kube-system
          labels:
            tier: px-web-console
        spec:
          type: LoadBalancer
          ports:
            - port: 80
              name: http
            - port: 443
              name: https
          selector:
            tier: px-web-console
  PXNodeGetPutListRoleStack:
    DependsOn: PortworxNamespaceStack
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      # The lambda function that executes the manifest against the cluster. This is created in one of the parent stacks
      ServiceToken: !Ref KubeManifestLambdaArn
      # S3 path to the encrypted config file eg. s3://my-bucket/kube/config.encrypted
      KubeConfigPath: !Ref KubeConfigPath
      # context for KMS to use when decrypting the file
      KubeConfigKmsContext: !Ref KubeConfigKmsContext
      # Kubernetes manifest
      Manifest:
        kind: ClusterRole
        apiVersion: rbac.authorization.k8s.io/v1
        metadata:
           name: node-get-put-list-role
        rules:
        - apiGroups: [""]
          resources: ["secrets"]
          verbs: ["get", "list"]
        - apiGroups: [""]
          resources: ["nodes"]
          verbs: ["watch", "get", "update", "list"]
        - apiGroups: [""]
          resources: ["pods"]
          verbs: ["delete", "get", "list", "watch", "update"]
        - apiGroups: [""]
          resources: ["persistentvolumeclaims", "persistentvolumes"]
          verbs: ["get", "list"]
        - apiGroups: [""]
          resources: ["configmaps"]
          verbs: ["get", "list", "update", "create"]
        - apiGroups: ["extensions"]
          resources: ["podsecuritypolicies"]
          resourceNames: ["privileged"]
          verbs: ["use"]
        - apiGroups: ["portworx.io"]
          resources: ["volumeplacementstrategies"]
          verbs: ["get", "list"]
        - apiGroups: ["stork.libopenstorage.org"]
          resources: ["backuplocations"]
          verbs: ["get", "list"]
  PXNodeRoleBindingStack:
    DependsOn: PortworxNamespaceStack
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      # The lambda function that executes the manifest against the cluster. This is created in one of the parent stacks
      ServiceToken: !Ref KubeManifestLambdaArn
      # S3 path to the encrypted config file eg. s3://my-bucket/kube/config.encrypted
      KubeConfigPath: !Ref KubeConfigPath
      # context for KMS to use when decrypting the file
      KubeConfigKmsContext: !Ref KubeConfigKmsContext
      # Kubernetes manifest
      Manifest:
        kind: ClusterRoleBinding
        apiVersion: rbac.authorization.k8s.io/v1
        metadata:
          name: node-role-binding
        subjects:
        - kind: ServiceAccount
          name: px-account
          namespace: kube-system
        roleRef:
          kind: ClusterRole
          name: node-get-put-list-role
          apiGroup: rbac.authorization.k8s.io
  PXRoleBindingStack:
    DependsOn: PortworxNamespaceStack
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      # The lambda function that executes the manifest against the cluster. This is created in one of the parent stacks
      ServiceToken: !Ref KubeManifestLambdaArn
      # S3 path to the encrypted config file eg. s3://my-bucket/kube/config.encrypted
      KubeConfigPath: !Ref KubeConfigPath
      # context for KMS to use when decrypting the file
      KubeConfigKmsContext: !Ref KubeConfigKmsContext
      # Kubernetes manifest
      Manifest:
        kind: RoleBinding
        apiVersion: rbac.authorization.k8s.io/v1
        metadata:
          name: px-role-binding
          namespace: portworx
        subjects:
        - kind: ServiceAccount
          name: px-account
          namespace: kube-system
        roleRef:
          kind: Role
          name: px-role
          apiGroup: rbac.authorization.k8s.io
  PXRoleStack:
    DependsOn: PortworxNamespaceStack
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      # The lambda function that executes the manifest against the cluster. This is created in one of the parent stacks
      ServiceToken: !Ref KubeManifestLambdaArn
      # S3 path to the encrypted config file eg. s3://my-bucket/kube/config.encrypted
      KubeConfigPath: !Ref KubeConfigPath
      # context for KMS to use when decrypting the file
      KubeConfigKmsContext: !Ref KubeConfigKmsContext
      # Kubernetes manifest
      Manifest:
        kind: Role
        apiVersion: rbac.authorization.k8s.io/v1
        metadata:
          name: px-role
          namespace: portworx
        rules:
        - apiGroups: [""]
          resources: ["secrets"]
          verbs: ["get", "list", "create", "update", "patch"]
  PXApiStack:
    DependsOn: PortworxNamespaceStack
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      # The lambda function that executes the manifest against the cluster. This is created in one of the parent stacks
      ServiceToken: !Ref KubeManifestLambdaArn
      # S3 path to the encrypted config file eg. s3://my-bucket/kube/config.encrypted
      KubeConfigPath: !Ref KubeConfigPath
      # context for KMS to use when decrypting the file
      KubeConfigKmsContext: !Ref KubeConfigKmsContext
      # Kubernetes manifest
      Manifest:
        kind: Service
        apiVersion: v1
        metadata:
          name: portworx-api
          namespace: kube-system
          labels:
            name: portworx-api
        spec:
          selector:
            name: portworx-api
          type: NodePort
          ports:
            - name: px-api
              protocol: TCP
              port: 9001
              targetPort: 9001
            - name: px-sdk
              protocol: TCP
              port: 9020
              targetPort: 9020
            - name: px-rest-gateway
              protocol: TCP
              port: 9021
              targetPort: 9021
  PXServiceStack:
    DependsOn: PortworxNamespaceStack
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      # The lambda function that executes the manifest against the cluster. This is created in one of the parent stacks
      ServiceToken: !Ref KubeManifestLambdaArn
      # S3 path to the encrypted config file eg. s3://my-bucket/kube/config.encrypted
      KubeConfigPath: !Ref KubeConfigPath
      # context for KMS to use when decrypting the file
      KubeConfigKmsContext: !Ref KubeConfigKmsContext
      # Kubernetes manifest
      Manifest:
        kind: Service
        apiVersion: v1
        metadata:
          name: portworx-service
          namespace: kube-system
          labels:
            name: portworx
        spec:
          selector:
            name: portworx
          type: NodePort
          ports:
            - name: px-api
              protocol: TCP
              port: 9001
              targetPort: 9001
            - name: px-kvdb
              protocol: TCP
              port: 9019
              targetPort: 9019
            - name: px-sdk
              protocol: TCP
              port: 9020
              targetPort: 9020
            - name: px-rest-gateway
              protocol: TCP
              port: 9021
              targetPort: 9021
  PXStorkAccountStack:
    DependsOn: PortworxNamespaceStack
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      # The lambda function that executes the manifest against the cluster. This is created in one of the parent stacks
      ServiceToken: !Ref KubeManifestLambdaArn
      # S3 path to the encrypted config file eg. s3://my-bucket/kube/config.encrypted
      KubeConfigPath: !Ref KubeConfigPath
      # context for KMS to use when decrypting the file
      KubeConfigKmsContext: !Ref KubeConfigKmsContext
      # Kubernetes manifest
      Manifest:
        apiVersion: v1
        kind: ServiceAccount
        metadata:
          name: stork-account
          namespace: kube-system
  PXStorkConfigStack:
    DependsOn: PortworxNamespaceStack
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      # The lambda function that executes the manifest against the cluster. This is created in one of the parent stacks
      ServiceToken: !Ref KubeManifestLambdaArn
      # S3 path to the encrypted config file eg. s3://my-bucket/kube/config.encrypted
      KubeConfigPath: !Ref KubeConfigPath
      # context for KMS to use when decrypting the file
      KubeConfigKmsContext: !Ref KubeConfigKmsContext
      # Kubernetes manifest
      Manifest:
        apiVersion: v1
        kind: ConfigMap
        metadata:
          name: stork-config
          namespace: kube-system
        data:
          policy.cfg: |-
            {
              "kind": "Policy",
              "apiVersion": "v1",
              "extenders": [
                {
                  "urlPrefix": "http://stork-service.kube-system:8099",
                  "apiVersion": "v1beta1",
                  "filterVerb": "filter",
                  "prioritizeVerb": "prioritize",
                  "weight": 5,
                  "enableHttps": false,
                  "nodeCacheCapable": false
                }
              ]
            }
  PXStorkDeploymentStack:
    DependsOn: PortworxNamespaceStack
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      # The lambda function that executes the manifest against the cluster. This is created in one of the parent stacks
      ServiceToken: !Ref KubeManifestLambdaArn
      # S3 path to the encrypted config file eg. s3://my-bucket/kube/config.encrypted
      KubeConfigPath: !Ref KubeConfigPath
      # context for KMS to use when decrypting the file
      KubeConfigKmsContext: !Ref KubeConfigKmsContext
      # Kubernetes manifest
      Manifest:
        apiVersion: extensions/v1beta1
        kind: Deployment
        metadata:
          annotations:
            scheduler.alpha.kubernetes.io/critical-pod: ""
          labels:
            tier: control-plane
          name: stork
          namespace: kube-system
        spec:
          strategy:
            rollingUpdate:
              maxSurge: 1
              maxUnavailable: 1
            type: RollingUpdate
          replicas: 3
          template:
            metadata:
              annotations:
                scheduler.alpha.kubernetes.io/critical-pod: ""
              labels:
                name: stork
                tier: control-plane
            spec:
              containers:
              - command:
                - /stork
                - --driver=pxd
                - --verbose
                - --leader-elect=true
                - --health-monitor-interval=120
                imagePullPolicy: Always
                image: openstorage/stork:2.3.1
                env:
                - name: "PX_SERVICE_NAME"
                  value: "portworx-api"
                resources:
                  requests:
                    cpu: '0.1'
                name: stork
              hostPID: false
              affinity:
                podAntiAffinity:
                  requiredDuringSchedulingIgnoredDuringExecution:
                    - labelSelector:
                        matchExpressions:
                          - key: "name"
                            operator: In
                            values:
                            - stork
                      topologyKey: "kubernetes.io/hostname"
              serviceAccountName: stork-account
  PXStorkRoleBindingStack:
    DependsOn: PortworxNamespaceStack
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      # The lambda function that executes the manifest against the cluster. This is created in one of the parent stacks
      ServiceToken: !Ref KubeManifestLambdaArn
      # S3 path to the encrypted config file eg. s3://my-bucket/kube/config.encrypted
      KubeConfigPath: !Ref KubeConfigPath
      # context for KMS to use when decrypting the file
      KubeConfigKmsContext: !Ref KubeConfigKmsContext
      # Kubernetes manifest
      Manifest:
        kind: ClusterRoleBinding
        apiVersion: rbac.authorization.k8s.io/v1
        metadata:
          name: stork-role-binding
        subjects:
        - kind: ServiceAccount
          name: stork-account
          namespace: kube-system
        roleRef:
          kind: ClusterRole
          name: stork-role
          apiGroup: rbac.authorization.k8s.io
  PXStorkRoleStack:
    DependsOn: PortworxNamespaceStack
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      # The lambda function that executes the manifest against the cluster. This is created in one of the parent stacks
      ServiceToken: !Ref KubeManifestLambdaArn
      # S3 path to the encrypted config file eg. s3://my-bucket/kube/config.encrypted
      KubeConfigPath: !Ref KubeConfigPath
      # context for KMS to use when decrypting the file
      KubeConfigKmsContext: !Ref KubeConfigKmsContext
      # Kubernetes manifest
      Manifest:
        kind: ClusterRole
        apiVersion: rbac.authorization.k8s.io/v1
        metadata:
           name: stork-role
        rules:
          - apiGroups: ["*"]
            resources: ["*"]
            verbs: ["*"]
  PXStorkSchedulerAccountStack:
    DependsOn: PortworxNamespaceStack
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      # The lambda function that executes the manifest against the cluster. This is created in one of the parent stacks
      ServiceToken: !Ref KubeManifestLambdaArn
      # S3 path to the encrypted config file eg. s3://my-bucket/kube/config.encrypted
      KubeConfigPath: !Ref KubeConfigPath
      # context for KMS to use when decrypting the file
      KubeConfigKmsContext: !Ref KubeConfigKmsContext
      # Kubernetes manifest
      Manifest:
        apiVersion: v1
        kind: ServiceAccount
        metadata:
          name: stork-scheduler-account
          namespace: kube-system
  PXStorkSchedulerDeploymentStack:
    DependsOn: PortworxNamespaceStack
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      # The lambda function that executes the manifest against the cluster. This is created in one of the parent stacks
      ServiceToken: !Ref KubeManifestLambdaArn
      # S3 path to the encrypted config file eg. s3://my-bucket/kube/config.encrypted
      KubeConfigPath: !Ref KubeConfigPath
      # context for KMS to use when decrypting the file
      KubeConfigKmsContext: !Ref KubeConfigKmsContext
      # k8s version
      PXKubernetesVersion: !Ref PXKubernetesVersion
      # Kubernetes manifest
      Manifest:
        apiVersion: apps/v1beta1
        kind: Deployment
        metadata:
          labels:
            component: scheduler
            tier: control-plane
            name: stork-scheduler
          name: stork-scheduler
          namespace: kube-system
        spec:
          replicas: 3
          template:
            metadata:
              labels:
                component: scheduler
                tier: control-plane
              name: stork-scheduler
            spec:
              containers:
              - command:
                - /usr/local/bin/kube-scheduler
                - --address=0.0.0.0
                - --leader-elect=true
                - --scheduler-name=stork
                - --policy-configmap=stork-config
                - --policy-configmap-namespace=kube-system
                - --lock-object-name=stork-scheduler
                image: !Join [ ":v", [ "gcr.io/google_containers/kube-scheduler-amd64", !Join [ ".", [ !Ref PXKubernetesVersion, "0"] ] ] ]
                livenessProbe:
                  httpGet:
                    path: /healthz
                    port: 10251
                  initialDelaySeconds: 15
                name: stork-scheduler
                readinessProbe:
                  httpGet:
                    path: /healthz
                    port: 10251
                resources:
                  requests:
                    cpu: '0.1'
              affinity:
                podAntiAffinity:
                  requiredDuringSchedulingIgnoredDuringExecution:
                    - labelSelector:
                        matchExpressions:
                          - key: "name"
                            operator: In
                            values:
                            - stork-scheduler
                      topologyKey: "kubernetes.io/hostname"
              hostPID: false
              serviceAccountName: stork-scheduler-account
  PXStorkSchedulerRoleBindingStack:
    DependsOn: PortworxNamespaceStack
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      # The lambda function that executes the manifest against the cluster. This is created in one of the parent stacks
      ServiceToken: !Ref KubeManifestLambdaArn
      # S3 path to the encrypted config file eg. s3://my-bucket/kube/config.encrypted
      KubeConfigPath: !Ref KubeConfigPath
      # context for KMS to use when decrypting the file
      KubeConfigKmsContext: !Ref KubeConfigKmsContext
      # Kubernetes manifest
      Manifest:
        kind: ClusterRoleBinding
        apiVersion: rbac.authorization.k8s.io/v1
        metadata:
          name: stork-scheduler-role-binding
        subjects:
        - kind: ServiceAccount
          name: stork-scheduler-account
          namespace: kube-system
        roleRef:
          kind: ClusterRole
          name: stork-scheduler-role
          apiGroup: rbac.authorization.k8s.io
  PXStorkSchedulerRoleStack:
    DependsOn: PortworxNamespaceStack
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      # The lambda function that executes the manifest against the cluster. This is created in one of the parent stacks
      ServiceToken: !Ref KubeManifestLambdaArn
      # S3 path to the encrypted config file eg. s3://my-bucket/kube/config.encrypted
      KubeConfigPath: !Ref KubeConfigPath
      # context for KMS to use when decrypting the file
      KubeConfigKmsContext: !Ref KubeConfigKmsContext
      # Kubernetes manifest
      Manifest:
        kind: ClusterRole
        apiVersion: rbac.authorization.k8s.io/v1
        metadata:
          name: stork-scheduler-role
        rules:
          - apiGroups: [""]
            resources: ["endpoints"]
            verbs: ["get", "create", "update"]
          - apiGroups: [""]
            resources: ["configmaps"]
            verbs: ["get"]
          - apiGroups: [""]
            resources: ["events"]
            verbs: ["create", "patch", "update"]
          - apiGroups: [""]
            resourceNames: ["kube-scheduler"]
            resources: ["endpoints"]
            verbs: ["delete", "get", "patch", "update"]
          - apiGroups: [""]
            resources: ["nodes"]
            verbs: ["get", "list", "watch"]
          - apiGroups: [""]
            resources: ["pods"]
            verbs: ["delete", "get", "list", "watch"]
          - apiGroups: [""]
            resources: ["bindings", "pods/binding"]
            verbs: ["create"]
          - apiGroups: [""]
            resources: ["pods/status"]
            verbs: ["patch", "update"]
          - apiGroups: [""]
            resources: ["replicationcontrollers", "services"]
            verbs: ["get", "list", "watch"]
          - apiGroups: ["apps", "extensions"]
            resources: ["replicasets"]
            verbs: ["get", "list", "watch"]
          - apiGroups: ["apps"]
            resources: ["statefulsets"]
            verbs: ["get", "list", "watch"]
          - apiGroups: ["policy"]
            resources: ["poddisruptionbudgets"]
            verbs: ["get", "list", "watch"]
          - apiGroups: [""]
            resources: ["persistentvolumeclaims", "persistentvolumes"]
            verbs: ["get", "list", "watch"]
          - apiGroups: ["storage.k8s.io"]
            resources: ["storageclasses"]
            verbs: ["get", "list", "watch"]
  PXStorkServiceStack:
    DependsOn: PortworxNamespaceStack
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      # The lambda function that executes the manifest against the cluster. This is created in one of the parent stacks
      ServiceToken: !Ref KubeManifestLambdaArn
      # S3 path to the encrypted config file eg. s3://my-bucket/kube/config.encrypted
      KubeConfigPath: !Ref KubeConfigPath
      # context for KMS to use when decrypting the file
      KubeConfigKmsContext: !Ref KubeConfigKmsContext
      # Kubernetes manifest
      Manifest:
        kind: Service
        apiVersion: v1
        metadata:
          name: stork-service
          namespace: kube-system
        spec:
          selector:
            name: stork
          ports:
            - protocol: TCP
              port: 8099
              targetPort: 8099
  PXStorkSnapshotStorageClassStack:
    DependsOn: PortworxNamespaceStack
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      # The lambda function that executes the manifest against the cluster. This is created in one of the parent stacks
      ServiceToken: !Ref KubeManifestLambdaArn
      # S3 path to the encrypted config file eg. s3://my-bucket/kube/config.encrypted
      KubeConfigPath: !Ref KubeConfigPath
      # context for KMS to use when decrypting the file
      KubeConfigKmsContext: !Ref KubeConfigKmsContext
      # Kubernetes manifest
      Manifest:
        kind: StorageClass
        apiVersion: storage.k8s.io/v1
        metadata:
          name: stork-snapshot-sc
        provisioner: stork-snapshot
  PXPvcControllerAccountStack:
    DependsOn: PortworxNamespaceStack
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      # The lambda function that executes the manifest against the cluster. This is created in one of the parent stacks
      ServiceToken: !Ref KubeManifestLambdaArn
      # S3 path to the encrypted config file eg. s3://my-bucket/kube/config.encrypted
      KubeConfigPath: !Ref KubeConfigPath
      # context for KMS to use when decrypting the file
      KubeConfigKmsContext: !Ref KubeConfigKmsContext
      # Kubernetes manifest
      Manifest:
        apiVersion: v1
        kind: ServiceAccount
        metadata:
          name: portworx-pvc-controller-account
          namespace: kube-system
  PXPvcControllerRoleBindingStack:
    DependsOn: PortworxNamespaceStack
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      # The lambda function that executes the manifest against the cluster. This is created in one of the parent stacks
      ServiceToken: !Ref KubeManifestLambdaArn
      # S3 path to the encrypted config file eg. s3://my-bucket/kube/config.encrypted
      KubeConfigPath: !Ref KubeConfigPath
      # context for KMS to use when decrypting the file
      KubeConfigKmsContext: !Ref KubeConfigKmsContext
      # Kubernetes manifest
      Manifest:
        kind: ClusterRoleBinding
        apiVersion: rbac.authorization.k8s.io/v1
        metadata:
          name: portworx-pvc-controller-role-binding
        subjects:
        - kind: ServiceAccount
          name: portworx-pvc-controller-account
          namespace: kube-system
        roleRef:
          kind: ClusterRole
          name: portworx-pvc-controller-role
          apiGroup: rbac.authorization.k8s.io
  PXPvcControllerDeploymentStack:
    DependsOn: PortworxNamespaceStack
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      # The lambda function that executes the manifest against the cluster. This is created in one of the parent stacks
      ServiceToken: !Ref KubeManifestLambdaArn
      # S3 path to the encrypted config file eg. s3://my-bucket/kube/config.encrypted
      KubeConfigPath: !Ref KubeConfigPath
      # context for KMS to use when decrypting the file
      KubeConfigKmsContext: !Ref KubeConfigKmsContext
      # k8s version
      PXKubernetesVersion: !Ref PXKubernetesVersion
      # Kubernetes manifest
      Manifest:
        apiVersion: extensions/v1beta1
        kind: Deployment
        metadata:
          annotations:
            scheduler.alpha.kubernetes.io/critical-pod: ""
          labels:
            tier: control-plane
          name: portworx-pvc-controller
          namespace: kube-system
        spec:
          replicas: 3
          strategy:
            rollingUpdate:
              maxSurge: 1
              maxUnavailable: 1
            type: RollingUpdate
          template:
            metadata:
              annotations:
                scheduler.alpha.kubernetes.io/critical-pod: ""
              labels:
                name: portworx-pvc-controller
                tier: control-plane
            spec:
              containers:
              - command:
                - kube-controller-manager
                - --leader-elect=true
                - --address=0.0.0.0
                - --controllers=persistentvolume-binder,persistentvolume-expander
                - --use-service-account-credentials=true
                - --leader-elect-resource-lock=configmaps
                image: !Join [ ":v", [ "gcr.io/google_containers/kube-controller-manager-amd64", !Join [ ".", [ !Ref PXKubernetesVersion, "0"] ] ] ]
                livenessProbe:
                  failureThreshold: 8
                  httpGet:
                    host: 127.0.0.1
                    path: /healthz
                    port: 10252
                    scheme: HTTP
                  initialDelaySeconds: 15
                  timeoutSeconds: 15
                name: portworx-pvc-controller-manager
                resources:
                  requests:
                    cpu: 200m
              hostNetwork: true
              affinity:
                podAntiAffinity:
                  requiredDuringSchedulingIgnoredDuringExecution:
                    - labelSelector:
                        matchExpressions:
                          - key: "name"
                            operator: In
                            values:
                            - portworx-pvc-controller
                      topologyKey: "kubernetes.io/hostname"
              serviceAccountName: portworx-pvc-controller-account
  PXPvcControllerRoleStack:
    DependsOn: PortworxNamespaceStack
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      # The lambda function that executes the manifest against the cluster. This is created in one of the parent stacks
      ServiceToken: !Ref KubeManifestLambdaArn
      # S3 path to the encrypted config file eg. s3://my-bucket/kube/config.encrypted
      KubeConfigPath: !Ref KubeConfigPath
      # context for KMS to use when decrypting the file
      KubeConfigKmsContext: !Ref KubeConfigKmsContext
      # Kubernetes manifest
      Manifest:
        kind: ClusterRole
        apiVersion: rbac.authorization.k8s.io/v1
        metadata:
           name: portworx-pvc-controller-role
        rules:
        - apiGroups: [""]
          resources: ["persistentvolumes"]
          verbs: ["create","delete","get","list","update","watch"]
        - apiGroups: [""]
          resources: ["persistentvolumes/status"]
          verbs: ["update"]
        - apiGroups: [""]
          resources: ["persistentvolumeclaims"]
          verbs: ["get", "list", "update", "watch"]
        - apiGroups: [""]
          resources: ["persistentvolumeclaims/status"]
          verbs: ["update"]
        - apiGroups: [""]
          resources: ["pods"]
          verbs: ["create", "delete", "get", "list", "watch"]
        - apiGroups: ["storage.k8s.io"]
          resources: ["storageclasses"]
          verbs: ["get", "list", "watch"]
        - apiGroups: [""]
          resources: ["endpoints", "services"]
          verbs: ["create", "delete", "get", "update"]
        - apiGroups: [""]
          resources: ["secrets"]
          verbs: ["get", "list"]
        - apiGroups: [""]
          resources: ["nodes"]
          verbs: ["get", "list", "watch"]
        - apiGroups: [""]
          resources: ["events"]
          verbs: ["watch", "create", "patch", "update"]
        - apiGroups: [""]
          resources: ["serviceaccounts"]
          verbs: ["get", "create"]
        - apiGroups: [""]
          resources: ["configmaps"]
          verbs: ["get", "create", "update"]
  PXVolumePlacementStrategiesStack:
    DependsOn: PortworxNamespaceStack
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      # The lambda function that executes the manifest against the cluster. This is created in one of the parent stacks
      ServiceToken: !Ref KubeManifestLambdaArn
      # S3 path to the encrypted config file eg. s3://my-bucket/kube/config.encrypted
      KubeConfigPath: !Ref KubeConfigPath
      # context for KMS to use when decrypting the file
      KubeConfigKmsContext: !Ref KubeConfigKmsContext
      # Kubernetes manifest
      Manifest:
        apiVersion: apiextensions.k8s.io/v1beta1
        kind: CustomResourceDefinition
        metadata:
          name: volumeplacementstrategies.portworx.io
        spec:
          group: portworx.io
          versions:
            - name: v1beta2
              served: true
              storage: true
            - name: v1beta1
              served: false
              storage: false
          scope: Cluster
          names:
            plural: volumeplacementstrategies
            singular: volumeplacementstrategy
            kind: VolumePlacementStrategy
            shortNames:
            - vps
            - vp
  PXApiDSStack:
    DependsOn: PortworxNamespaceStack
    Type: "Custom::KubeManifest"
    Version: '1.0'
    Properties:
      # The lambda function that executes the manifest against the cluster. This is created in one of the parent stacks
      ServiceToken: !Ref KubeManifestLambdaArn
      # S3 path to the encrypted config file eg. s3://my-bucket/kube/config.encrypted
      KubeConfigPath: !Ref KubeConfigPath
      # context for KMS to use when decrypting the file
      KubeConfigKmsContext: !Ref KubeConfigKmsContext
      # false 
      PortworxPxEnabledNotInValue: !Ref PortworxPxEnabledNotInValue
      # Kubernetes manifest
      Manifest: !Sub |
        apiVersion: extensions/v1beta1
        kind: DaemonSet
        metadata:
          name: portworx-api
          namespace: kube-system
        spec:
          minReadySeconds: 0
          updateStrategy:
            type: RollingUpdate
            rollingUpdate:
              maxUnavailable: 100%
          template:
            metadata:
              labels:
                name: portworx-api
            spec:
              affinity:
                nodeAffinity:
                  requiredDuringSchedulingIgnoredDuringExecution:
                    nodeSelectorTerms:
                    - matchExpressions:
                      - key: px/enabled
                        operator: NotIn
                        values:
                        - "${PortworxPxEnabledNotInValue}"
                      - key: node-role.kubernetes.io/master
                        operator: DoesNotExist
              hostNetwork: true
              hostPID: false
              containers:
                - name: portworx-api
                  image: k8s.gcr.io/pause:3.1
                  imagePullPolicy: Always
                  readinessProbe:
                    periodSeconds: 10
                    httpGet:
                      host: 127.0.0.1
                      path: /status
                      port: 9001
              restartPolicy: Always
              serviceAccountName: px-account
  PXNodePolicyStack:
    Type: AWS::IAM::Policy
    Properties:
      PolicyName: PwxWorkerNodePolicy
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Action:
          - ec2:AttachVolume
          - ec2:DetachVolume
          - ec2:CreateTags
          - ec2:CreateVolume
          - ec2:DeleteTags
          - ec2:DeleteVolume
          - ec2:DescribeTags
          - ec2:DescribeVolumeAttribute
          - ec2:DescribeVolumesModifications
          - ec2:DescribeVolumeStatus
          - ec2:DescribeVolumes
          - ec2:DescribeInstances
          Resource: "*"
      Roles:
      - Ref: NodeGroupIAMRole
Outputs:
  PortworxNamspaceUid:
    Value: !GetAtt PortworxNamespaceStack.uid
  PortworxDaemonsetUid:
    Value: !GetAtt PortworxDaemonSetStack.uid
